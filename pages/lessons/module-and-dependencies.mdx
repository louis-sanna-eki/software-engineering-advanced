# Modules and Dependencies: The Two Pillars of System Architecture

![Modules, Interfaces, and Dependencies](/modules.png)

Complex systems are built on two fundamental architectural concepts: **Modules** and **Dependencies**. Understanding these concepts is crucial for building maintainable software.

## 1. Modules: Divide to Better Reign

The first pillar of system architecture is modularization - breaking down complex systems into smaller, manageable pieces. This principle follows the age-old wisdom of "divide and conquer."

### Benefits of Modularization

- **Reduced Complexity**: Each module handles a specific concern
- **Better Maintainability**: Changes are localized to specific modules
- **Easier Testing**: Modules can be tested in isolation
- **Team Scalability**: Different teams can work on different modules

### Example: Well-Modularized System

```python
# users/domain.py
from typing import TypedDict

class User(TypedDict):
    id: str
    name: str
    email: str

def validate_user(user: User) -> bool:
    return bool(user["email"] and user["name"])

# orders/domain.py
from decimal import Decimal
from typing import TypedDict

class Order(TypedDict):
    id: str
    total: Decimal
    status: str

def calculate_total(items: list[dict]) -> Decimal:
    return sum(item["price"] * item["quantity"] for item in items)
```

## 2. Dependencies: The Art of Assembly

While modules help us break down complexity, dependencies define how these modules work together. However, poorly managed dependencies can negate all the benefits of modularization.

### Interfaces: Contracts Between Modules

Interfaces serve as contracts that define how modules can communicate with each other. They specify:
- What operations are available
- What data is required
- What results to expect

Think of interfaces like a contract between a restaurant and its customers:
- The menu (interface) defines what you can order
- You don't need to know how the kitchen (implementation) works
- The kitchen can be reorganized without affecting customers

```python
# A clear contract for storing orders
class OrderStorage(Protocol):
    def save(self, order: Order) -> None:
        """Save an order to storage.
        
        Args:
            order: The order to save
            
        Raises:
            StorageError: If save fails
        """
        ...
    
    def get(self, order_id: str) -> Order:
        """Retrieve an order by ID.
        
        Args:
            order_id: The order's unique identifier
            
        Returns:
            The order if found
            
        Raises:
            NotFoundError: If order doesn't exist
        """
        ...
```

### The Dependency Problem

The main challenge with dependencies is avoiding cycles. When modules depend on each other cyclically, they effectively become one large, tightly coupled module.

### ❌ Bad: Circular Dependencies

```python
# users/domain.py
from orders.domain import get_user_orders  # Depends on orders

def get_user_details(user_id: str) -> dict:
    orders = get_user_orders(user_id)  # Circular dependency!
    return {"id": user_id, "orders": orders}

# orders/domain.py
from users.domain import get_user_details  # Depends on users

def get_user_orders(user_id: str) -> list:
    user = get_user_details(user_id)  # Circular dependency!
    return [{"order_id": "1", "user": user}]
```

### ✅ Good: Breaking Cycles with Interfaces

The solution is to make dependencies point in one direction by using interfaces:

```python
from typing import Protocol, List
from decimal import Decimal

# core/interfaces.py
class OrderStorage(Protocol):
    def get_orders(self, user_id: str) -> List[dict]: ...

# users/domain.py
def get_user_details(
    user_id: str,
    order_storage: OrderStorage  # Depend on interface
) -> dict:
    orders = order_storage.get_orders(user_id)
    return {"id": user_id, "orders": orders}

# orders/storage.py
class SQLOrderStorage:
    def get_orders(self, user_id: str) -> List[dict]:
        # Implementation details here
        return [{"order_id": "1", "user_id": user_id}]
```

## Local Context: Enabling Dependency Injection

Local context is a powerful tool that enables proper dependency injection and inversion of control. It helps solve the dependency problems we discussed earlier in a clean way.

### From Direct Dependencies to Injection

Remember our earlier problem with circular dependencies:
```python
# ❌ Bad: Direct import creates tight coupling
from orders.domain import get_user_orders

def get_user_details(user_id: str) -> dict:
    orders = get_user_orders(user_id)  # Direct dependency
    return {"id": user_id, "orders": orders}
```

Using local context, we can inject dependencies instead:
```python
from typing import Protocol, TypedDict

# Define what we need, not where it comes from
class OrderFetcher(Protocol):
    def get_orders(self, user_id: str) -> list[dict]: ...

# Context carries our dependencies
class UserContext(TypedDict):
    order_fetcher: OrderFetcher
    debug: bool

def get_user_details(user_id: str, ctx: UserContext) -> dict:
    # Dependency comes from context, not import
    orders = ctx["order_fetcher"].get_orders(user_id)
    return {"id": user_id, "orders": orders}

# Usage with different implementations
def main():
    # Development context
    with user_context(
        order_fetcher=lambda user_id: [],  # Mock implementation
        debug=True
    ) as ctx:
        get_user_details("123", ctx)
```

### Why This Matters

1. **Inversion of Control**
   - Business logic defines what it needs (interfaces)
   - Context provides concrete implementations
   - Dependencies point inward toward core logic

2. **Flexible Assembly**
   - Swap implementations without changing code
   - Mix and match modules freely
   - No circular dependencies possible

3. **Testing and Development**
   ```python
   # Test with mocks
   test_ctx = {
       "order_fetcher": lambda user_id: [{"id": "test"}],
       "debug": True
   }
   
   # Production with real implementation
   prod_ctx = {
       "order_fetcher": SQLOrderStorage(),
       "debug": False
   }
   ```

## Key Takeaways

1. **Modularization** is about breaking down complexity
   - Each module should have a single responsibility
   - Modules should be independently maintainable

2. **Dependencies** determine system flexibility
   - Avoid circular dependencies at all costs
   - Use interfaces to decouple modules
   - Inject dependencies through context

3. **Interfaces** are contracts between modules
   - They define what modules need
   - They hide implementation details
   - Context connects interfaces to implementations

## Additional Resources

- [Clean Architecture by Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Domain-Driven Design](https://martinfowler.com/bliki/DomainDrivenDesign.html)
- [SOLID Principles](https://en.wikipedia.org/wiki/SOLID)