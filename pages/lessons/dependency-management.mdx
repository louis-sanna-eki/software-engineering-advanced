# Dependency Management: Building Maintainable Systems

Managing dependencies is crucial for building maintainable systems. This lesson explores how to structure dependencies to avoid common pitfalls.

## The Dependency Rule

Dependencies should point inward, toward high-level policy:
1. Business logic shouldn't depend on implementation details
2. Core domain shouldn't know about infrastructure
3. Interfaces belong to the business logic, not the implementations

### Example: Core vs Infrastructure

```python
from typing import TypedDict, Protocol, List
from decimal import Decimal

# Core domain (business logic)
class Product(TypedDict):
    id: str
    name: str
    price: Decimal

class ProductStorage(Protocol):
    def get(self, product_id: str) -> Product: ...
    def save(self, product: Product) -> None: ...

def apply_discount(product: Product, percent: Decimal) -> Product:
    return {**product, "price": product["price"] * (1 - percent / 100)}

# Infrastructure (implementation details)
def create_sqlite_storage(db_path: str) -> ProductStorage:
    import sqlite3
    
    def get(product_id: str) -> Product:
        with sqlite3.connect(db_path) as conn:
            row = conn.execute(
                "SELECT * FROM products WHERE id = ?", 
                [product_id]
            ).fetchone()
            return {
                "id": row[0],
                "name": row[1],
                "price": Decimal(row[2])
            }
    
    def save(product: Product) -> None:
        with sqlite3.connect(db_path) as conn:
            conn.execute(
                "INSERT OR REPLACE INTO products VALUES (?, ?, ?)",
                [product["id"], product["name"], str(product["price"])]
            )
    
    return type("SQLiteStorage", (), {
        "get": get,
        "save": save
    })()
```

## Context-Based Dependency Injection

Use context managers to handle dependencies elegantly:

```python
from contextlib import contextmanager
from typing import Iterator, TypedDict, Protocol
from decimal import Decimal

# Define the application context
class AppContext(TypedDict):
    storage: ProductStorage
    cache_ttl: int
    debug: bool

# Create and manage context
@contextmanager
def app_context(config_path: str) -> Iterator[AppContext]:
    # Set up dependencies
    storage = create_sqlite_storage(config_path)
    
    try:
        # Yield the context
        yield {
            "storage": storage,
            "cache_ttl": 3600,
            "debug": True
        }
    finally:
        # Clean up (close connections, etc)
        pass

# Use context in business logic
def process_product(product_id: str, ctx: AppContext) -> Product:
    product = ctx["storage"].get(product_id)
    if ctx["debug"]:
        print(f"Processing product: {product}")
    return product

# Usage
with app_context("db.sqlite") as ctx:
    product = process_product("123", ctx)
```

## Avoiding Dependency Cycles

Dependency cycles make code hard to understand and maintain. Here's how to avoid them:

### ❌ Bad: Circular Dependencies

```python
# user.py
from order import get_user_orders  # Imports from order.py

class User(TypedDict):
    id: str
    name: str

def get_user(user_id: str) -> User:
    return {"id": user_id, "name": "Test"}

def get_user_with_orders(user_id: str) -> dict:
    user = get_user(user_id)
    orders = get_user_orders(user_id)  # Circular dependency!
    return {**user, "orders": orders}

# order.py
from user import get_user  # Imports from user.py

class Order(TypedDict):
    id: str
    user_id: str

def get_user_orders(user_id: str) -> List[Order]:
    user = get_user(user_id)  # Circular dependency!
    return [{"id": "1", "user_id": user["id"]}]
```

### ✅ Good: Break Cycles with Interfaces

```python
# core/interfaces.py
class UserProvider(Protocol):
    def get_user(self, user_id: str) -> User: ...

class OrderProvider(Protocol):
    def get_orders(self, user_id: str) -> List[Order]: ...

# users/domain.py
def get_user_details(
    user_id: str,
    orders: OrderProvider  # Depend on interface
) -> dict:
    user = {"id": user_id, "name": "Test"}
    return {**user, "orders": orders.get_orders(user_id)}

# orders/domain.py
def get_user_orders(
    user_id: str,
    users: UserProvider  # Depend on interface
) -> List[Order]:
    user = users.get_user(user_id)
    return [{"id": "1", "user_id": user["id"]}]
```

### Best Practices for Avoiding Cycles

1. **Create a Core Domain Package**
   ```
   src/
     core/
       interfaces.py   # All interfaces live here
       types.py        # All shared types live here
     users/
       domain.py      # User business logic
     orders/
       domain.py      # Order business logic
   ```

2. **Use Events Instead of Direct Calls**
   ```python
   from typing import Protocol, Callable
   from decimal import Decimal
   
   # Define events
   class OrderCreated(TypedDict):
       order_id: str
       user_id: str
       total: Decimal

   # Event handlers don't create cycles
   def notify_user(event: OrderCreated) -> None:
       send_email(
           to=get_user_email(event["user_id"]),
           subject=f"Order {event['order_id']} created",
           total=event["total"]
       )

   def update_stats(event: OrderCreated) -> None:
       increment_user_order_count(event["user_id"])
   ```

3. **Split Large Modules**
   ```python
   # Instead of one large module
   from massive_module import (
       User, Order, Product,
       get_user, create_order, find_product
   )
   
   # Split into focused modules
   from core.types import User, Order, Product
   from users.domain import get_user
   from orders.domain import create_order
   from products.domain import find_product
   ```

## Key Takeaways

- Dependencies should point inward toward business logic
- Use context managers for clean dependency injection
- Break cycles using interfaces and events
- Keep shared interfaces in a core package
- Split large modules into focused domains

## Additional Resources

- [Dependency Inversion Principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)
- [Python Context Managers](https://docs.python.org/3/library/contextlib.html)
- [Domain-Driven Design](https://www.domainlanguage.com/ddd/) 