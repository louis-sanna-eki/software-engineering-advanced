# Component-Based Architecture: Building Maintainable Systems

Component-based architecture helps us build maintainable systems by organizing code into independent, reusable pieces. This approach naturally builds on our functional programming principles.

## What Makes a Good Component?

A good component:
1. Has a clear, single responsibility
2. Exposes a well-defined interface
3. Can be tested in isolation
4. Manages its own state

### Example: Payment Processing Component

```python
from typing import TypedDict, Literal, Protocol
from decimal import Decimal

# Clear interface using TypedDict
class PaymentRequest(TypedDict):
    amount: Decimal
    currency: str
    payment_method: Literal["card", "bank_transfer"]
    customer_id: str

class PaymentResult(TypedDict):
    success: bool
    transaction_id: str
    error_message: str

# Protocol defines the interface
class PaymentProcessor(Protocol):
    def process_payment(self, request: PaymentRequest) -> PaymentResult: ...

# Concrete implementation
def create_stripe_processor(api_key: str) -> PaymentProcessor:
    def process_payment(request: PaymentRequest) -> PaymentResult:
        # Implementation details hidden
        return {
            "success": True,
            "transaction_id": "tx_123",
            "error_message": ""
        }
    
    return type("StripeProcessor", (), {
        "process_payment": process_payment
    })()

# Alternative implementation
def create_paypal_processor(credentials: dict) -> PaymentProcessor:
    def process_payment(request: PaymentRequest) -> PaymentResult:
        return {
            "success": True,
            "transaction_id": "pp_456",
            "error_message": ""
        }
    
    return type("PayPalProcessor", (), {
        "process_payment": process_payment
    })()
```

## Loose Coupling Through Interfaces

Components should depend on interfaces, not implementations:

```python
from typing import TypedDict, Protocol, List
from decimal import Decimal

# Domain types
class OrderItem(TypedDict):
    product_id: str
    quantity: int
    price: Decimal

class Order(TypedDict):
    items: List[OrderItem]
    total: Decimal
    customer_id: str

# Component interfaces
class InventoryChecker(Protocol):
    def check_availability(self, items: List[OrderItem]) -> bool: ...

class PaymentProcessor(Protocol):
    def process_payment(self, amount: Decimal, customer_id: str) -> bool: ...

class OrderNotifier(Protocol):
    def notify_order_created(self, order: Order) -> None: ...

# Order processor component
def create_order_processor(
    inventory: InventoryChecker,
    payments: PaymentProcessor,
    notifier: OrderNotifier
):
    def process_order(order: Order) -> bool:
        # Each step is independent and testable
        if not inventory.check_availability(order["items"]):
            return False
            
        if not payments.process_payment(order["total"], order["customer_id"]):
            return False
            
        notifier.notify_order_created(order)
        return True
            
    return process_order
```

## Colocation: Organize by Feature

Instead of organizing by technical type (models, views, controllers), organize by feature:

```
❌ Bad Organization
src/
  models/
    user.py
    order.py
    product.py
  controllers/
    user_controller.py
    order_controller.py
  services/
    user_service.py
    order_service.py

✅ Good Organization
src/
  users/
    types.py      # TypedDicts for user domain
    storage.py    # User storage interface
    actions.py    # Pure functions for user operations
    api.py        # API endpoints for user features
  orders/
    types.py      # TypedDicts for order domain
    validation.py # Order validation rules
    processing.py # Order processing logic
    api.py        # API endpoints for orders
```

## The Open-Closed Principle

Components should be open for extension but closed for modification. Use composition of pure functions:

```python
from typing import TypedDict, Callable, List
from decimal import Decimal

# Price rule component
class PriceRule(TypedDict):
    name: str
    calculate: Callable[[Decimal], Decimal]

def create_discount_rule(percentage: Decimal) -> PriceRule:
    """Creates a percentage discount rule"""
    def calculate(price: Decimal) -> Decimal:
        return price * (1 - percentage / 100)
    
    return {
        "name": f"{percentage}% discount",
        "calculate": calculate
    }

def create_minimum_price_rule(minimum: Decimal) -> PriceRule:
    """Creates a minimum price rule"""
    def calculate(price: Decimal) -> Decimal:
        return max(price, minimum)
    
    return {
        "name": f"Minimum ${minimum}",
        "calculate": calculate
    }

# Compose rules
def apply_price_rules(
    base_price: Decimal,
    rules: List[PriceRule]
) -> Decimal:
    price = base_price
    for rule in rules:
        price = rule["calculate"](price)
    return price

# Usage
rules = [
    create_discount_rule(Decimal("10")),
    create_minimum_price_rule(Decimal("5"))
]

final_price = apply_price_rules(Decimal("100"), rules)
```

## Vertical vs Horizontal Splitting

Two ways to split components:

### Vertical (by Feature)
```python
# users/types.py
class User(TypedDict):
    id: str
    name: str
    email: str

# users/validation.py
def validate_email(email: str) -> bool:
    return "@" in email

# users/storage.py
class UserStorage(Protocol):
    def save(self, user: User) -> None: ...
    def get(self, user_id: str) -> User: ...

# users/api.py
def create_user_endpoints(storage: UserStorage):
    def create_user(user: User) -> None:
        if not validate_email(user["email"]):
            raise ValueError("Invalid email")
        storage.save(user)
    
    return {"create_user": create_user}
```

### Horizontal (by Layer)
```python
# shared/storage.py
class Storage(Protocol):
    def save(self, key: str, data: dict) -> None: ...
    def get(self, key: str) -> dict: ...

# shared/validation.py
def validate_required(data: dict, fields: List[str]) -> bool:
    return all(field in data for field in fields)

# shared/api.py
def create_crud_endpoints(
    storage: Storage,
    validate: Callable[[dict], bool]
):
    def create(data: dict) -> None:
        if not validate(data):
            raise ValueError("Invalid data")
        storage.save(data["id"], data)
    
    return {"create": create}
```

## Key Takeaways

- Use TypedDict and Protocol for clear interfaces
- Organize code by feature, not technical type
- Components should have a single responsibility
- Depend on interfaces, not implementations
- Use pure functions and composition

## Additional Resources

- [Python Protocol Documentation](https://docs.python.org/3/library/typing.html#typing.Protocol)
- [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Feature-Sliced Design](https://feature-sliced.design/) 