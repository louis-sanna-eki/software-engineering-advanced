# Modules and Dependencies: The Two Pillars of System Architecture

![Modules, Interfaces, and Dependencies](/modules.png)

Complex systems are built on fundamental architectural concepts that help manage complexity. Let's explore each one:

## 1. Modules: Divide and Conquer

The first pillar is modularization - breaking down complex systems into smaller, manageable pieces. This follows the age-old wisdom of "divide and conquer."

### Benefits of Modularization

- **Reduced Complexity**: Each module handles a specific concern
- **Better Maintainability**: Changes are localized to specific modules
- **Easier Testing**: Modules can be tested in isolation
- **Team Scalability**: Different teams can work on different modules

### Example: Well-Modularized System

```python
# users/domain.py
from typing import TypedDict

class User(TypedDict):
    id: str
    name: str
    email: str

def validate_user(user: User) -> bool:
    return bool(user["email"] and user["name"])

# orders/domain.py
from decimal import Decimal
from typing import TypedDict

class Order(TypedDict):
    id: str
    total: Decimal
    status: str

def calculate_total(items: list[dict]) -> Decimal:
    return sum(item["price"] * item["quantity"] for item in items)
```

## 2. Dependencies: Assembling Modules

Once we have modules, we need to connect them. Dependencies define these connections - how modules use each other's functionality.

### The Dependency Problem

Dependencies can quickly become problematic. The main challenge is avoiding cycles:

```python
# âŒ Bad: Circular Dependencies
# users/domain.py
from orders.domain import get_user_orders  # Depends on orders

def get_user_details(user_id: str) -> dict:
    orders = get_user_orders(user_id)  # Circular dependency!
    return {"id": user_id, "orders": orders}

# orders/domain.py
from users.domain import get_user_details  # Depends on users

def get_user_orders(user_id: str) -> list:
    user = get_user_details(user_id)  # Circular dependency!
    return [{"order_id": "1", "user": user}]
```

When modules depend on each other cyclically:
- They effectively become one large module
- Changes in one affect all others
- Testing becomes difficult
- Reuse becomes impossible

## 3. Interfaces: Contracts Between Modules

Interfaces solve the dependency problem by defining contracts between modules. They specify:
- What operations are available
- What data is required
- What results to expect

Think of interfaces like a restaurant menu:
- The menu (interface) defines what you can order
- You don't need to know how the kitchen (implementation) works
- The kitchen can be reorganized without affecting customers

### Example: Clear Interface Contract

```python
from typing import Protocol, List

# Define the contract
class OrderStorage(Protocol):
    def save(self, order: Order) -> None:
        """Save an order to storage.
        
        Args:
            order: The order to save
            
        Raises:
            StorageError: If save fails
        """
        ...
    
    def get(self, order_id: str) -> Order:
        """Retrieve an order by ID.
        
        Args:
            order_id: The order's unique identifier
            
        Returns:
            The order if found
            
        Raises:
            NotFoundError: If order doesn't exist
        """
        ...

# Implementation follows the contract
def get_user_details(
    user_id: str,
    order_storage: OrderStorage  # Depend on interface, not implementation
) -> dict:
    orders = order_storage.get_orders(user_id)
    return {"id": user_id, "orders": orders}
```

## 4. Local Context: Managing Dependencies

Local context provides a clean way to manage dependencies through injection. It connects modules while respecting their interfaces.

### From Direct Dependencies to Injection

```python
from typing import Protocol, TypedDict

# Define what we need (interface)
class OrderFetcher(Protocol):
    def get_orders(self, user_id: str) -> list[dict]: ...

# Context carries dependencies
class UserContext(TypedDict):
    order_fetcher: OrderFetcher
    debug: bool

def get_user_details(user_id: str, ctx: UserContext) -> dict:
    # Use dependency through context
    orders = ctx["order_fetcher"].get_orders(user_id)
    return {"id": user_id, "orders": orders}

# Wire different implementations
def main():
    # Development version
    with user_context(
        order_fetcher=lambda user_id: [],  # Mock implementation
        debug=True
    ) as ctx:
        get_user_details("123", ctx)
```

### Why Context Matters

1. **Inversion of Control**
   - Business logic defines what it needs (interfaces)
   - Context provides concrete implementations
   - Dependencies point inward toward core logic

2. **Flexible Assembly**
   - Swap implementations without changing code
   - Mix and match modules freely
   - No circular dependencies possible

3. **Testing and Development**
   ```python
   # Test with mocks
   test_ctx = {
       "order_fetcher": lambda user_id: [{"id": "test"}],
       "debug": True
   }
   
   # Production with real implementation
   prod_ctx = {
       "order_fetcher": SQLOrderStorage(),
       "debug": False
   }
   ```

## Key Takeaways

1. **Modules** break down complexity
   - Each module has a single responsibility
   - Changes are localized
   - Testing is simpler

2. **Dependencies** connect modules
   - Avoid cycles at all costs
   - Dependencies should be explicit
   - Direction of dependencies matters

3. **Interfaces** define contracts
   - Specify what, not how
   - Hide implementation details
   - Enable module independence

4. **Local Context** manages assembly
   - Injects dependencies cleanly
   - Enables easy testing
   - Keeps modules decoupled

## Additional Resources

- [Clean Architecture by Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Domain-Driven Design](https://martinfowler.com/bliki/DomainDrivenDesign.html)
- [SOLID Principles](https://en.wikipedia.org/wiki/SOLID)