# Functional Programming: Simplifying Code with Pure Functions

Functional programming helps us write more predictable code by emphasizing pure functions and managing side effects. This approach naturally supports our happy path philosophy.

## Pure Functions: The Foundation

Pure functions are the building blocks of clean code because they:
1. Always return the same output for the same input
2. Have no side effects
3. Make testing and debugging easier

### Example: Pure vs Impure Functions

```python
from typing import TypedDict, List
from decimal import Decimal
from datetime import datetime

# Impure: Result depends on external state
def get_active_users(users: List[dict]) -> List[dict]:
    now = datetime.now()  # External state!
    return [user for user in users 
            if user["last_login"] > now - timedelta(days=30)]

# Pure: Result only depends on input
def get_active_users(
    users: List[dict],
    reference_date: datetime,
    max_inactive_days: int
) -> List[dict]:
    return [user for user in users 
            if user["last_login"] > reference_date - timedelta(days=max_inactive_days)]
```

## Using Neutral Elements Instead of Special Cases

In functional programming, we use neutral elements (like 0 for addition or 1 for multiplication) instead of special cases:

```python
from typing import TypedDict, List, Literal
from decimal import Decimal

# Instead of boolean flags or null checks:
def apply_discount(price: float, discount_enabled: bool = False) -> float:
    if discount_enabled:
        return price * 0.9
    return price

# Better: Use neutral multiplier (1.0 means no discount)
class PriceModifier(TypedDict):
    multiplier: Decimal

def apply_modifier(price: Decimal, modifier: PriceModifier) -> Decimal:
    return price * modifier["multiplier"]

# Neutral element (no modification)
neutral_price: PriceModifier = {"multiplier": Decimal("1.0")}
discount_10: PriceModifier = {"multiplier": Decimal("0.9")}
discount_20: PriceModifier = {"multiplier": Decimal("0.8")}

# Usage
price = Decimal("100")
final_price = apply_modifier(price, neutral_price)  # No change
discounted = apply_modifier(price, discount_10)     # 90
```

### Composing Transformations with Neutral Elements

```python
from typing import TypedDict, List

class Transform(TypedDict):
    scale: Decimal      # 1.0 is neutral (no scaling)
    rotation: Decimal   # 0.0 is neutral (no rotation)
    opacity: Decimal    # 1.0 is neutral (fully visible)

def compose_transforms(t1: Transform, t2: Transform) -> Transform:
    return {
        "scale": t1["scale"] * t2["scale"],      # Multiplication: 1.0 is neutral
        "rotation": t1["rotation"] + t2["rotation"],  # Addition: 0.0 is neutral
        "opacity": t1["opacity"] * t2["opacity"]      # Multiplication: 1.0 is neutral
    }

# Neutral transform (does nothing)
neutral_transform: Transform = {
    "scale": Decimal("1.0"),
    "rotation": Decimal("0.0"),
    "opacity": Decimal("1.0")
}

# Any transformation composed with neutral gives the same result
result = compose_transforms(some_transform, neutral_transform)  # same as some_transform
```

### Collections and Neutral Elements

```python
from typing import TypedDict, Set, List

# Instead of None or special cases, use empty collections
class FilterConfig(TypedDict):
    include_tags: Set[str]  # Empty set means include all
    exclude_tags: Set[str]  # Empty set means exclude none

def filter_items(items: List[dict], config: FilterConfig) -> List[dict]:
    return [
        item for item in items
        if (not config["include_tags"] or  # Empty set = include all
            item["tags"] & config["include_tags"]) and
        not (item["tags"] & config["exclude_tags"])  # Empty set = exclude none
    ]

# Neutral configuration (no filtering)
neutral_filter: FilterConfig = {
    "include_tags": set(),  # Empty set is neutral
    "exclude_tags": set()   # Empty set is neutral
}
```

### Function Composition with Neutral Elements

```python
from typing import TypedDict, Callable, List
from decimal import Decimal

# Instead of optional transformations
def maybe_transform(value: str, transform: Callable[[str], str] | None) -> str:
    if transform is not None:
        return transform(value)
    return value

# Better: Use identity function as neutral element
def identity(x: any) -> any:
    return x

def compose_functions(
    functions: List[Callable[[any], any]] = [identity]  # identity is neutral
) -> Callable[[any], any]:
    def composed(x: any) -> any:
        result = x
        for f in functions:
            result = f(result)
        return result
    return composed

# Example: Text processing pipeline
def uppercase(s: str) -> str: return s.upper()
def remove_spaces(s: str) -> str: return s.replace(" ", "")

# Different pipelines using neutral element
neutral_pipeline = compose_functions()  # Just identity
simple_pipeline = compose_functions([uppercase])
full_pipeline = compose_functions([uppercase, remove_spaces])
```

## Managing Side Effects

Side effects are necessary but should be:
1. Pushed to the edges of your system
2. Clearly identified and isolated
3. Easy to test and mock

### Example: Pure Core with Side Effects at Edges

```python
from typing import TypedDict, List
from decimal import Decimal

class OrderItem(TypedDict):
    product_id: str
    quantity: int
    price: Decimal

class Order(TypedDict):
    items: List[OrderItem]
    total: Decimal

# Pure core functions
def calculate_total(items: List[OrderItem]) -> Decimal:
    return sum(item["price"] * item["quantity"] for item in items)

def validate_order(items: List[OrderItem]) -> bool:
    return all(
        item["quantity"] > 0 and item["price"] > Decimal("0")
        for item in items
    )

# Side effects at the edges
def process_order(items: List[OrderItem]) -> Order:
    if not validate_order(items):
        raise ValueError("Invalid order")
        
    total = calculate_total(items)
    
    # Side effects only at the end
    save_to_database(items, total)
    notify_warehouse(items)
    send_confirmation_email(total)
    
    return {"items": items, "total": total}
```

## Key Takeaways

- Use pure functions for core logic
- Replace special cases with neutral elements
- Push side effects to the edges
- Use composition with neutral elements
- Let the type system help enforce correctness

## Additional Resources

- [Functional Programming HOWTO](https://docs.python.org/3/howto/functional.html)
- [Monoids in Practice](https://fsharpforfunandprofit.com/posts/monoids-without-tears/)
- [Type-Driven Development](https://www.manning.com/books/type-driven-development-with-python) 