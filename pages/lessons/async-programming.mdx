# Asynchronous Programming: Patterns and Best Practices

Asynchronous programming helps us handle operations that might take time without blocking execution. This lesson explores patterns for writing maintainable async code.

![Asynchronous vs Synchronous Programming](/async.png)

## Async Patterns

### 1. Task-Based Programming

```python
from typing import TypedDict, List
import asyncio
from decimal import Decimal

class Order(TypedDict):
    id: str
    items: List[dict]
    total: Decimal

# ❌ Bad: Mixing async and sync code
async def process_order(order: Order) -> None:
    # Blocking call in async function!
    if db.check_inventory(order["items"]):
        payment = await process_payment(order["total"])
        # More blocking calls
        db.update_inventory(order["items"])
        db.save_order(order)
        await send_confirmation(order["id"])

# ✅ Better: Everything is async
async def process_order(order: Order) -> None:
    if not await check_inventory(order["items"]):
        raise ValueError("Items not available")
    
    async with transaction():
        await process_payment(order["total"])
        await update_inventory(order["items"])
        await save_order(order)
    
    await send_confirmation(order["id"])
```

### 2. Concurrent Operations

```python
from typing import TypedDict, List
import asyncio
from decimal import Decimal

class ProductInfo(TypedDict):
    id: str
    name: str
    price: Decimal
    stock: int

# ❌ Bad: Sequential requests
async def get_products(ids: List[str]) -> List[ProductInfo]:
    products = []
    for id in ids:
        # Each request waits for the previous one
        product = await api.get_product(id)
        products.append(product)
    return products

# ✅ Better: Concurrent requests
async def get_products(ids: List[str]) -> List[ProductInfo]:
    # All requests start at once
    tasks = [api.get_product(id) for id in ids]
    return await asyncio.gather(*tasks)

# ✅ Better: Controlled concurrency
async def get_products(ids: List[str], chunk_size: int = 5) -> List[ProductInfo]:
    products = []
    for i in range(0, len(ids), chunk_size):
        chunk = ids[i:i + chunk_size]
        tasks = [api.get_product(id) for id in chunk]
        chunk_products = await asyncio.gather(*tasks)
        products.extend(chunk_products)
    return products
```

## Performance Considerations

### 1. Connection Pooling

```python
from typing import TypedDict, AsyncIterator
import aiohttp
from contextlib import asynccontextmanager

# ❌ Bad: Creating new connections for each request
async def get_user(user_id: str) -> dict:
    async with aiohttp.ClientSession() as session:
        async with session.get(f"/users/{user_id}") as resp:
            return await resp.json()

# ✅ Better: Reuse connections
class APIClient:
    def __init__(self):
        self.session: Optional[aiohttp.ClientSession] = None
    
    async def __aenter__(self) -> "APIClient":
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, *args) -> None:
        if self.session:
            await self.session.close()
            self.session = None
    
    async def get_user(self, user_id: str) -> dict:
        async with self.session.get(f"/users/{user_id}") as resp:
            return await resp.json()

# Usage
async def process_users(user_ids: List[str]) -> None:
    async with APIClient() as client:
        tasks = [client.get_user(id) for id in user_ids]
        users = await asyncio.gather(*tasks)
```

### 2. Resource Management

Semaphores control access to limited resources in async applications, preventing resource exhaustion.

```python
from typing import TypedDict, AsyncIterator
import asyncio
from contextlib import asynccontextmanager

class DatabasePool:
    def __init__(self, max_size: int = 10):
        self.semaphore = asyncio.Semaphore(max_size)
    
    @asynccontextmanager
    async def acquire(self) -> AsyncIterator[None]:
        async with self.semaphore:
            yield

# Example: Database Connection Pool
pool = DatabasePool(max_size=3)

async def process_item(item_id: int) -> None:
    async with pool.acquire():
        await slow_database_operation(item_id)

async def process_many_items(items: List[int]) -> None:
    tasks = [process_item(i) for i in items]
    await asyncio.gather(*tasks)

# Example: API Rate Limiting
class RateLimitedAPI:
    def __init__(self, requests_per_second: int):
        self.semaphore = asyncio.Semaphore(requests_per_second)
        
    async def make_request(self, endpoint: str) -> dict:
        async with self.semaphore:
            async with aiohttp.ClientSession() as session:
                async with session.get(endpoint) as response:
                    await asyncio.sleep(1)  # Rate limit delay
                    return await response.json()

# Usage
api = RateLimitedAPI(requests_per_second=2)
endpoints = [f"/data/{i}" for i in range(5)]
results = await asyncio.gather(*[api.make_request(e) for e in endpoints])
```

Common use cases for semaphores:
1. Database connection pooling
2. Rate limiting API requests
3. Controlling access to shared resources

## Testing Async Code

```python
import pytest
from typing import AsyncIterator
from unittest.mock import AsyncMock

# Fixtures for testing
@pytest.fixture
async def api_client() -> AsyncIterator[APIClient]:
    async with APIClient() as client:
        yield client

# Mock external services
@pytest.fixture
def mock_payment_service() -> AsyncMock:
    return AsyncMock(spec=PaymentService)

# Test async functions
async def test_process_payment(
    api_client: APIClient,
    mock_payment_service: AsyncMock
) -> None:
    # Arrange
    mock_payment_service.charge.return_value = {
        "success": True,
        "transaction_id": "123"
    }
    
    # Act
    result = await api_client.process_payment(
        amount=Decimal("100"),
        service=mock_payment_service
    )
    
    # Assert
    assert result["success"]
    mock_payment_service.charge.assert_called_once_with(
        amount=Decimal("100")
    )
```

## Key Takeaways

- Keep async and sync code separate
- Use concurrent operations carefully
- Handle errors gracefully
- Manage resources efficiently
- Test async code thoroughly

## Additional Resources

- [Python asyncio Documentation](https://docs.python.org/3/library/asyncio.html)
- [AIOHTTP Documentation](https://docs.aiohttp.org/)
- [Testing Async Code](https://pytest-asyncio.readthedocs.io/) 