# Code Complexity: Making Code Understandable

Code complexity is about how difficult code is to understand and modify. This lesson explores how to measure and reduce complexity.

## Cyclomatic Complexity

Cyclomatic complexity measures the number of independent paths through code. Each decision point (if, while, for) adds complexity.

### Example: High Complexity

```python
from typing import TypedDict, List, Literal
from decimal import Decimal
from enum import Enum, auto

class Order(TypedDict):
    items: List[dict]
    user_id: str
    coupon: str | None
    total: Decimal

# ❌ High complexity: Many nested conditions
def apply_discount(order: Order) -> Decimal:
    if order["coupon"]:
        if order["coupon"].startswith("NEW"):
            if len(order["items"]) > 3:
                return Decimal("0.25")  # 25% off
            else:
                return Decimal("0.15")  # 15% off
        elif order["coupon"].startswith("VIP"):
            if sum(item["price"] for item in order["items"]) > 100:
                if is_long_term_customer(order["user_id"]):
                    return Decimal("0.30")  # 30% off
                return Decimal("0.20")  # 20% off
    return Decimal("0")  # No discount

# ✅ Better: Flatten conditions, use early returns
def apply_discount(order: Order) -> Decimal:
    if not order["coupon"]:
        return Decimal("0")
    
    total = sum(item["price"] for item in order["items"])
    item_count = len(order["items"])
    
    if order["coupon"].startswith("NEW"):
        return Decimal("0.25") if item_count > 3 else Decimal("0.15")
        
    if order["coupon"].startswith("VIP") and total > 100:
        return Decimal("0.30") if is_long_term_customer(order["user_id"]) else Decimal("0.20")
    
    return Decimal("0")
```

## Decision Trees

Break complex decisions into smaller, focused functions:

```python
from typing import TypedDict, Protocol, List, Literal
from decimal import Decimal
from enum import Enum, auto

# Define clear types for decisions
class UserType(Enum):
    NEW = auto()
    REGULAR = auto()
    VIP = auto()

class OrderMetrics(TypedDict):
    total: Decimal
    item_count: int
    user_type: UserType

# Break decisions into focused functions
def calculate_metrics(order: Order) -> OrderMetrics:
    return {
        "total": sum(item["price"] for item in order["items"]),
        "item_count": len(order["items"]),
        "user_type": get_user_type(order["user_id"])
    }

def get_base_discount(user_type: UserType) -> Decimal:
    return {
        UserType.NEW: Decimal("0.15"),
        UserType.REGULAR: Decimal("0.10"),
        UserType.VIP: Decimal("0.20")
    }[user_type]

def apply_volume_bonus(
    base_discount: Decimal,
    metrics: OrderMetrics
) -> Decimal:
    if metrics["item_count"] > 3:
        return base_discount + Decimal("0.10")
    return base_discount

def apply_total_bonus(
    discount: Decimal,
    metrics: OrderMetrics
) -> Decimal:
    if metrics["total"] > 100:
        return discount + Decimal("0.05")
    return discount

# Compose simple functions
def calculate_discount(order: Order) -> Decimal:
    metrics = calculate_metrics(order)
    discount = get_base_discount(metrics["user_type"])
    discount = apply_volume_bonus(discount, metrics)
    discount = apply_total_bonus(discount, metrics)
    return discount
```

## Keeping Complexity Low

### 1. Use Type Systems

```python
from typing import TypedDict, Literal, Union
from decimal import Decimal

# Make impossible states unrepresentable
class PendingOrder(TypedDict):
    status: Literal["pending"]
    items: List[dict]
    total: Decimal

class ConfirmedOrder(TypedDict):
    status: Literal["confirmed"]
    items: List[dict]
    total: Decimal
    payment_id: str

class CancelledOrder(TypedDict):
    status: Literal["cancelled"]
    items: List[dict]
    total: Decimal
    reason: str

Order = Union[PendingOrder, ConfirmedOrder, CancelledOrder]

# Type system prevents invalid states
def process_order(order: Order) -> None:
    match order["status"]:
        case "pending":
            # Can't access payment_id here - type system prevents it
            start_processing(order)
        case "confirmed":
            # payment_id is guaranteed to exist here
            send_confirmation(order["payment_id"])
        case "cancelled":
            # reason is guaranteed to exist here
            handle_cancellation(order["reason"])
```

### 2. Use Pure Functions

```python
from typing import TypedDict, List
from decimal import Decimal
from datetime import datetime

# ❌ Complex: State affects behavior
class ShoppingCart:
    def __init__(self):
        self.items: List[dict] = []
        self.discounts: List[str] = []
        self.last_modified = datetime.now()
    
    def add_item(self, item: dict) -> None:
        self.items.append(item)
        self.last_modified = datetime.now()
        if len(self.items) > 3:
            self.discounts.append("VOLUME")
        if sum(i["price"] for i in self.items) > 100:
            self.discounts.append("TOTAL")
    
    def get_total(self) -> Decimal:
        total = sum(item["price"] for item in self.items)
        for discount in self.discounts:
            if discount == "VOLUME":
                total *= Decimal("0.9")
            elif discount == "TOTAL":
                total *= Decimal("0.85")
        return total

# ✅ Better: Pure functions, explicit state
class Cart(TypedDict):
    items: List[dict]

def add_item(cart: Cart, item: dict) -> Cart:
    return {
        "items": [*cart["items"], item]
    }

def calculate_discounts(cart: Cart) -> List[str]:
    discounts = []
    if len(cart["items"]) > 3:
        discounts.append("VOLUME")
    if sum(i["price"] for i in cart["items"]) > 100:
        discounts.append("TOTAL")
    return discounts

def apply_discount(total: Decimal, discount: str) -> Decimal:
    match discount:
        case "VOLUME":
            return total * Decimal("0.9")
        case "TOTAL":
            return total * Decimal("0.85")
        case _:
            return total

def calculate_total(cart: Cart) -> Decimal:
    total = sum(item["price"] for item in cart["items"])
    return reduce(apply_discount, calculate_discounts(cart), total)
```

### 3. Use Events for Complex Workflows

```python
from typing import TypedDict, Literal, Protocol
from decimal import Decimal

# Define clear events
class OrderCreated(TypedDict):
    type: Literal["order_created"]
    order_id: str
    total: Decimal

class PaymentReceived(TypedDict):
    type: Literal["payment_received"]
    order_id: str
    payment_id: str

class OrderShipped(TypedDict):
    type: Literal["order_shipped"]
    order_id: str
    tracking_id: str

Event = OrderCreated | PaymentReceived | OrderShipped

# Handle each event independently
def handle_event(event: Event) -> None:
    match event["type"]:
        case "order_created":
            initiate_payment(event["order_id"], event["total"])
        case "payment_received":
            prepare_shipment(event["order_id"])
        case "order_shipped":
            send_tracking_info(event["order_id"], event["tracking_id"])
```

## Code Refactoring Strategies

1. **Extract Till You Drop**
   ```python
   # ❌ Too much in one function
   def process_order(order: dict) -> None:
       # Validate
       if not order.get("user_id"):
           raise ValueError("Missing user")
       if not order.get("items"):
           raise ValueError("No items")
       
       # Calculate total
       total = Decimal("0")
       for item in order["items"]:
           if item["quantity"] <= 0:
               raise ValueError("Invalid quantity")
           if item["price"] <= 0:
               raise ValueError("Invalid price")
           total += item["price"] * item["quantity"]
       
       # Apply discount
       if total > 100:
           total *= Decimal("0.9")
       
       # Save
       db.save_order({**order, "total": total})
   
   # ✅ Better: Small, focused functions
   def validate_order(order: dict) -> None:
       if not order.get("user_id"):
           raise ValueError("Missing user")
       if not order.get("items"):
           raise ValueError("No items")
   
   def validate_item(item: dict) -> None:
       if item["quantity"] <= 0:
           raise ValueError("Invalid quantity")
       if item["price"] <= 0:
           raise ValueError("Invalid price")
   
   def calculate_item_total(item: dict) -> Decimal:
       return item["price"] * item["quantity"]
   
   def apply_discount(total: Decimal) -> Decimal:
       if total > 100:
           return total * Decimal("0.9")
       return total
   
   def process_order(order: dict) -> None:
       validate_order(order)
       for item in order["items"]:
           validate_item(item)
       
       total = sum(calculate_item_total(item) for item in order["items"])
       final_total = apply_discount(total)
       
       db.save_order({**order, "total": final_total})
   ```

2. **Replace Conditionals with Polymorphism**
   ```python
   from typing import Protocol, TypedDict
   from decimal import Decimal
   
   # Define clear interfaces
   class PriceCalculator(Protocol):
       def calculate(self, base_price: Decimal) -> Decimal: ...
   
   # Implement specific strategies
   def create_regular_calculator() -> PriceCalculator:
       def calculate(base_price: Decimal) -> Decimal:
           return base_price
       return type("RegularCalculator", (), {"calculate": calculate})()
   
   def create_discount_calculator(percent: Decimal) -> PriceCalculator:
       def calculate(base_price: Decimal) -> Decimal:
           return base_price * (1 - percent / 100)
       return type("DiscountCalculator", (), {"calculate": calculate})()
   
   def create_bulk_calculator(threshold: int, discount: Decimal) -> PriceCalculator:
       def calculate(base_price: Decimal) -> Decimal:
           if base_price > threshold:
               return base_price * (1 - discount / 100)
           return base_price
       return type("BulkCalculator", (), {"calculate": calculate})()
   ```

## Key Takeaways

- Measure complexity through decision points
- Break complex decisions into simple steps
- Use type systems to prevent invalid states
- Prefer pure functions over stateful objects
- Use events for complex workflows
- Extract till you can't extract anymore

## Additional Resources

- [Cyclomatic Complexity](https://en.wikipedia.org/wiki/Cyclomatic_complexity)
- [Replace Conditional with Polymorphism](https://refactoring.guru/replace-conditional-with-polymorphism)
- [Pure Functions](https://en.wikipedia.org/wiki/Pure_function) 