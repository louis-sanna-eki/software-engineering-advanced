# Modules and Dependencies: The Two Pillars of System Architecture

Complex systems are built on two fundamental architectural concepts: **Modules** and **Dependencies**. Understanding these concepts is crucial for building maintainable software.

## 1. Modules: Divide to Better Reign

The first pillar of system architecture is modularization - breaking down complex systems into smaller, manageable pieces. This principle follows the age-old wisdom of "divide and conquer."

### Benefits of Modularization

- **Reduced Complexity**: Each module handles a specific concern
- **Better Maintainability**: Changes are localized to specific modules
- **Easier Testing**: Modules can be tested in isolation
- **Team Scalability**: Different teams can work on different modules

### Example: Well-Modularized System

```python
# users/domain.py
from typing import TypedDict

class User(TypedDict):
    id: str
    name: str
    email: str

def validate_user(user: User) -> bool:
    return bool(user["email"] and user["name"])

# orders/domain.py
from decimal import Decimal
from typing import TypedDict

class Order(TypedDict):
    id: str
    total: Decimal
    status: str

def calculate_total(items: list[dict]) -> Decimal:
    return sum(item["price"] * item["quantity"] for item in items)
```

## 2. Dependencies: The Art of Assembly

While modules help us break down complexity, dependencies define how these modules work together. However, poorly managed dependencies can negate all the benefits of modularization.

### Interfaces: Contracts Between Modules

Interfaces serve as contracts that define how modules can communicate with each other. They specify:
- What operations are available
- What data is required
- What results to expect

Think of interfaces like a contract between a restaurant and its customers:
- The menu (interface) defines what you can order
- You don't need to know how the kitchen (implementation) works
- The kitchen can be reorganized without affecting customers

```python
# A clear contract for storing orders
class OrderStorage(Protocol):
    def save(self, order: Order) -> None:
        """Save an order to storage.
        
        Args:
            order: The order to save
            
        Raises:
            StorageError: If save fails
        """
        ...
    
    def get(self, order_id: str) -> Order:
        """Retrieve an order by ID.
        
        Args:
            order_id: The order's unique identifier
            
        Returns:
            The order if found
            
        Raises:
            NotFoundError: If order doesn't exist
        """
        ...
```

### The Dependency Problem

The main challenge with dependencies is avoiding cycles. When modules depend on each other cyclically, they effectively become one large, tightly coupled module.

### ❌ Bad: Circular Dependencies

```python
# users/domain.py
from orders.domain import get_user_orders  # Depends on orders

def get_user_details(user_id: str) -> dict:
    orders = get_user_orders(user_id)  # Circular dependency!
    return {"id": user_id, "orders": orders}

# orders/domain.py
from users.domain import get_user_details  # Depends on users

def get_user_orders(user_id: str) -> list:
    user = get_user_details(user_id)  # Circular dependency!
    return [{"order_id": "1", "user": user}]
```

### ✅ Good: Breaking Cycles with Interfaces

The solution is to make dependencies point in one direction by using interfaces:

```python
from typing import Protocol, List
from decimal import Decimal

# core/interfaces.py
class OrderStorage(Protocol):
    def get_orders(self, user_id: str) -> List[dict]: ...

# users/domain.py
def get_user_details(
    user_id: str,
    order_storage: OrderStorage  # Depend on interface
) -> dict:
    orders = order_storage.get_orders(user_id)
    return {"id": user_id, "orders": orders}

# orders/storage.py
class SQLOrderStorage:
    def get_orders(self, user_id: str) -> List[dict]:
        # Implementation details here
        return [{"order_id": "1", "user_id": user_id}]
```

## Patterns at Different Abstraction Levels

These core ideas of modules, dependencies, and interfaces appear throughout software at different scales:

### 1. Function Level
```python
# Functions are modules with clear interfaces (parameters and return types)
def calculate_price(
    base_price: Decimal,
    tax_rate: Decimal,
    discount: Decimal
) -> Decimal:
    """A function's signature is its interface contract"""
    return base_price * (1 + tax_rate) * (1 - discount)
```

### 2. Class Level
```python
# Classes are modules that encapsulate related data and behavior
class ShoppingCart:
    """The public methods form the class's interface"""
    def add_item(self, item_id: str, quantity: int) -> None: ...
    def remove_item(self, item_id: str) -> None: ...
    def get_total(self) -> Decimal: ...
```

### 3. Package Level
```python
# __init__.py defines a package's public interface
from .internal import InternalClass

# Public interface
class PublicClass:
    def public_method(self): ...

# Hide implementation details
__all__ = ['PublicClass']
```

### 4. Service Level
```python
# RESTful API is an interface contract between services
from fastapi import FastAPI

app = FastAPI()

@app.get("/users/{user_id}")
async def get_user(user_id: str):
    """API endpoints are interfaces between client and server"""
    return {"id": user_id, "name": "John"}
```

### 5. System Level
```yaml
# Docker Compose defines interfaces between system components
services:
  web:
    image: myapp
    ports:
      - "8000:8000"
    depends_on:
      - db
  
  db:
    image: postgres
    environment:
      POSTGRES_PASSWORD: secret
```

## Best Practices for Managing Dependencies

1. **Dependencies Should Point Inward**
   - Business logic shouldn't depend on implementation details
   - Core domain shouldn't know about infrastructure
   - Interfaces belong to the business logic, not the implementations

2. **Use Dependency Injection**
```python
from dataclasses import dataclass
from typing import Protocol

class EmailSender(Protocol):
    def send(self, to: str, subject: str) -> None: ...

@dataclass
class OrderService:
    email_sender: EmailSender
    
    def create_order(self, user_id: str) -> None:
        # Business logic here
        self.email_sender.send(
            to="user@example.com",
            subject="Order Created"
        )
```

3. **Event-Based Communication**
   Instead of direct dependencies, use events to communicate between modules:

```python
from typing import Callable
from decimal import Decimal

# Define events
class OrderCreated(TypedDict):
    order_id: str
    total: Decimal

# Modules communicate through events
def notify_user(event: OrderCreated) -> None:
    send_email(
        subject=f"Order {event['order_id']} created",
        total=event["total"]
    )

def update_statistics(event: OrderCreated) -> None:
    increment_order_count()
```

## Key Takeaways

1. **Modularization** is about breaking down complexity
   - Each module should have a single responsibility
   - Modules should be independently maintainable

2. **Dependencies** determine system flexibility
   - Avoid circular dependencies at all costs
   - Use interfaces to decouple modules
   - Consider event-based communication for complex interactions

3. **Interfaces** are contracts between modules
   - They define how modules can interact
   - They hide implementation details
   - They appear at every level of abstraction

## Additional Resources

- [Clean Architecture by Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Domain-Driven Design](https://martinfowler.com/bliki/DomainDrivenDesign.html)
- [SOLID Principles](https://en.wikipedia.org/wiki/SOLID) 